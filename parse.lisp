(cl:in-package :xdoc)

(define-condition malformed (error)
  ((input :type xml-input
	  :initarg :in
	  :reader cond-in)
   (msg :type string
	:initarg :msg
	:reader cond-msg))
  (:report (lambda (c s)
	     (format s "Syntax error at line ~A, position ~A: ~A"
		     (line (cond-in c))
		     (pos (cond-in c))
		     (cond-msg c)))))

(defun emsg (in msg &rest args)
  (error 'malformed :in in :msg (apply #'format nil msg args)))

(defun name-start-char-p (c)
  (or (char= c #\:)
      (char= c #\_)
      (alpha-char-p c)
      (char<= #\uC0 c #\uD6)
      (char<= #\uD8 c #\uF6)
      (char<= #\uF8 c #\u2FF)
      (char<= #\u370 c #\u37D)
      (char<= #\u37F c #\u1FFF)
      (char<= #\u200C c #\u200D)
      (char<= #\u2070 c #\u218F)
      (char<= #\u2C00 c #\u2FEF)
      (char<= #\u3001 c #\uD7FF)
      (char<= #\uF900 c #\uFDCF)
      (char<= #\uFDF0 c #\uFFFD)
      (char<= #\u10000 c #\uEFFFF)))

(defun name-char-p (c)
  (or (name-start-char-p c)
      (char= c #\-)
      (char= c #\.)
      (digit-char-p c)
      (char= c #\uB7)
      (char<= #\u0300 c #\u036F)
      (char<= #\u203F c #\u2040)))

(defun terminal-char (char in)
  (with-output-to-string (string)
    (do ()
	((char= char (first-char in)))
      (write-char (get-char in) string))))

(defun get-character-reference (in)
  (let ((seq (terminal-char #\; in)))
    (cond ((string= "#x" seq)
	   (code-char (parse-integer seq :start 2 :radix 16)))
	  ((char= #\# (char seq 0))
	   (code-char (parse-integer seq :start 1 :radix 10)))
	  (t (or (cdr (assoc seq '(("lt" . #\<)
				   ("gt" . #\>)
				   ("amp" . #\&)
				   ("quot" . #\")
				   ("apos" . #\'))
			     :test #'string=))
		 (emsg in "Bad character reference \"~A\"" seq))))))

(defun get-name (in)
  (with-output-to-string (string)
    (unless (name-start-char-p (first-char in))
      (emsg in "Bad character in name: ~S" (first-char in)))
    (do ()
	((not (name-char-p (first-char in))))
      (write-char (get-char in) string))))

(defun whitespacep (char)
  (or (char= char #\space)
      (char= char #\tab)
      (char= char #\linefeed)
      (char= char #\return)
      (char= char #\newline)))

(defun whitespace (in)
  (do ()
      ((not (whitespacep (first-char in))))
    (discard 1 in)))

(defun expect-char (char in)
  (let ((had (get-char in)))
    (unless (char= char had)
      (emsg in "Expected char ~S, got ~S" char had))))

(defun terminal (string in)
  (when (and (char= (char string 0) (first-char in))
	     (string= string (peek-string (length string) in)))
    (discard (length string) in)
    t))

(defun get-cdata (string in)
  (do ()
      ((terminal "]]>" in))
    (write-char (get-char in) string)))

(defun pass-comment (in)
  (do ()
      ((terminal "-->" in))
    (discard 1 in)))

(defun get-meta (string in)
  (cond ((terminal "![CDATA[" in)
	 (get-cdata string in))
	((terminal "!--" in)
	 (pass-comment in))
	(t (emsg in "Invalid syntax in literal text"))))

(defun get-value (delimeter in &key cdata)
  (with-output-to-string (string)
    (when cdata
      (get-cdata string in))
    (do ((next (first-char in) (first-char in)))
	((char= delimeter next))
      (case next
	(#\& (discard 1 in) (write-char (get-character-reference in) string))
	(#\< (discard 1 in) (get-meta string in))
	(t (write-char (get-char in) string))))))

(defun get-attribute (in)
  (let ((name (get-name in)))
    (whitespace in)
    (expect-char #\= in)
    (whitespace in)
    (let ((delim (get-char in)))
      (unless (find delim #(#\" #\'))
	(emsg in "Malformed attributes list"))
      (let ((value (get-value delim in)))
	(discard 1 in)
	(whitespace in)
	(cons name value)))))

(defun get-attributes (in)
  (whitespace in)
  (do ((attrs nil (push (get-attribute in) attrs)))
      ((not (name-start-char-p (first-char in)))
       (nreverse attrs))
    (whitespace in)))

(defun pass-etc (in)
  (do ()
      ((terminal "]>" in))
    (discard 1 in)))

(defun get-prologue (in)
  (let ((name (get-name in))
	(attrs (get-attributes in)))
    (unless (terminal "?>" in)
      (emsg in "Badly formatted declaration arg"))
    (make-instance 'prologue :name name :attrs attrs)))

(defun get-document-tag (in)
  (let ((name (get-name in)))
    (whitespace in)
    (let ((attrs (get-attributes in)))
      (whitespace in)
      (case (first-char in)
	(#\/
	 (discard 1 in)
	 (expect-char #\> in)
	 (make-instance 'empty-tag :name name :attrs attrs))
	(#\>
	 (discard 1 in)
	 (make-instance 'start-tag :name name :attrs attrs))
	(t
	 (emsg in "Unexpected char in attribute list"))))))

(defun get-end-tag (in)
  (let ((name (get-name in)))
    (whitespace in)
    (expect-char #\> in)
    (make-instance 'end-tag :name name)))

(defun get-tag (in)
  (whitespace in)
  (cond ((terminal "<?" in)
	 (get-prologue in))
	((terminal "<!--" in)
	 (pass-comment in)
	 (get-tag in))
	((terminal "<![CDATA[" in)
	 (get-value #\< in :cdata t))
	((terminal "<!" in)
	 (pass-etc in)
	 (get-tag in))
	((terminal "</" in)
	 (get-end-tag in))
	((char= #\< (first-char in))
	 (discard 1 in)
	 (get-document-tag in))
	(t
	 (get-value #\< in))))

(defun get-children (tag in)
  (do ((children nil (push (finish-element child in) children))
       (child (get-tag in)
	      (get-tag in)))
      ((typep child 'end-tag)
       (if (string= (name child) (name tag))
	   (nreverse children)
	   (emsg in "Stray end tag")))))

(defun finish-tag (tag in)
  (let ((children (when (typep tag 'start-tag)
		    (get-children tag in))))
    (make-instance 'element
		   :name (name tag)
		   :attrs (attributes tag)
		   :children children)))

(defun finish-element (open in)
  (etypecase open
    (prologue (get-element in))
    (string open)
    (tag (finish-tag open in))))

(defun get-element (in)
  (finish-element (get-tag in) in))

(defun read-document-stream (stream)
  (let ((input (make-instance 'xml-input :source stream)))
    (whitespace input)
    (let ((elt1 (get-element input)))
      (if (not (typep elt1 'tag))
	  (get-element input)
	  elt1))))

(defun read-document-file (path)
  (with-open-file (file path)
    (read-document-stream file)))

(defmethod print-object ((object element) stream)
  (format stream "#<~A/>" (name object)))
